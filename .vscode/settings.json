{
  "liveServer.settings.port": 5506,
  "github.copilot.nextEditSuggestions.enabled": true,
  "chat.tools.terminal.autoApprove": {
    "1": true,
    "2": true,
    "/^python3\\s+-m\\s+http\\.server(\\s+\\d+)?(\\s+--bind\\s+\\S+)?$/": {
      "approve": true,
      "matchCommandLine": true
    },
    "/^node\\s+--check\\s+\\/Users\\/evgenijtazelnikov\\/Documents\\/kg\\/script\\.js$/": {
      "approve": true,
      "matchCommandLine": true
    },
    "/^python - <<'PY'\nscript = r\"\"\"\nimport tinycss2, pathlib, json, re\nfrom collections import defaultdict, Counter\ntext = pathlib\\.Path\\('/Users/evgenijtazelnikov/Documents/kg/styles\\.css'\\)\\.read_text\\(\\)\nstorage = defaultdict\\(list\\)\nmedia_ctx_re = re\\.compile\\(r'\\(min\\|max\\)-width\\\\\\\\s\\*:\\\\\\\\s\\*\\(\\[0-9\\.\\]\\+\\\\\\\\s\\*\\(\\?:px\\|rem\\|vw\\|vh\\|vmin\\|vmax\\|em\\|%\\)\\?\\)', re\\.I\\)\n\ndef split_selectors\\(selector_text\\):\n    parts = \\[\\]\n    buf = \\[\\]\n    depth = 0\n    for ch in selector_text:\n        if ch in '\\(\\[\\{' :\n            depth \\+= 1\n        elif ch in '\\)\\]\\}' and depth > 0:\n            depth -= 1\n        if ch == ',' and depth == 0:\n            sel = ''\\.join\\(buf\\)\\.strip\\(\\)\n            if sel:\n                parts\\.append\\(sel\\)\n            buf = \\[\\]\n        else:\n            buf\\.append\\(ch\\)\n    tail = ''\\.join\\(buf\\)\\.strip\\(\\)\n    if tail:\n        parts\\.append\\(tail\\)\n    return parts\n\nrules = tinycss2\\.parse_stylesheet\\(text, skip_comments=True, skip_whitespace=True\\)\n\nLAYOUT = \\{'display','position','top','right','bottom','left','width','min-width','max-width','height','min-height','max-height','margin','margin-top','margin-right','margin-bottom','margin-left','padding','padding-top','padding-right','padding-bottom','padding-left','grid','grid-template','grid-template-columns','grid-template-rows','grid-column','grid-row','grid-auto-flow','grid-auto-columns','grid-auto-rows','gap','column-gap','row-gap','align-items','justify-content','align-content','align-self','justify-items','flex','flex-grow','flex-shrink','flex-basis','flex-direction','flex-wrap','order','float','clear','overflow','overflow-x','overflow-y','object-fit','object-position','transform','transform-origin','clip-path','z-index','isolation','inset','inset-block','inset-inline','place-items','place-content'\\}\nTYPO = \\{'font','font-size','font-weight','font-family','font-style','line-height','letter-spacing','text-transform','text-decoration','text-align','text-indent','text-shadow','text-rendering','text-wrap','text-overflow','white-space','word-break','word-spacing','hyphens'\\}\nANIM = \\{'transition','transition-property','transition-duration','transition-delay','transition-timing-function','animation','animation-name','animation-duration','animation-delay','animation-direction','animation-iteration-count','animation-fill-mode','animation-play-state','@keyframes'\\}\n\ndef classify\\(prop\\):\n    prop = prop\\.lower\\(\\)\n    if prop in LAYOUT or prop\\.startswith\\('grid'\\) or prop\\.startswith\\('flex'\\) or prop\\.startswith\\('justify'\\) or prop\\.startswith\\('align'\\) or prop in \\{'max-lines','columns'\\}:\n        return 'layout'\n    if prop in TYPO:\n        return 'typography'\n    if prop in ANIM or prop\\.startswith\\('animation'\\):\n        return 'animation'\n    return 'skin'\n\nconflict_inputs = defaultdict\\(list\\)\n\n\ndef serialize\\(tokens\\):\n    return tinycss2\\.serialize\\(tokens\\)\\.strip\\(\\)\n\n\ndef parse_rule_list\\(tokens\\):\n    return tinycss2\\.parse_rule_list\\(tokens, skip_comments=True, skip_whitespace=True\\)\n\n\ndef gather\\(rules, ctx_stack\\):\n    for rule in rules:\n        if rule\\.type == 'at-rule':\n            if rule\\.content is None:\n                continue\n            inner = parse_rule_list\\(rule\\.content\\)\n            ctx = ctx_stack\\.copy\\(\\)\n            if rule\\.at_keyword\\.lower\\(\\) == 'media':\n                ctx\\.append\\(\\{'type':'media','text':serialize\\(rule\\.prelude\\)\\}\\)\n            else:\n                ctx\\.append\\(\\{'type':'at','text':'@'\\+rule\\.at_keyword\\}\\)\n            gather\\(inner, ctx\\)\n        elif rule\\.type == 'qualified-rule':\n            prelude_text = serialize\\(rule\\.prelude\\)\n            selectors = split_selectors\\(prelude_text\\)\n            if not selectors:\n                continue\n            decls = tinycss2\\.parse_declaration_list\\(rule\\.content, skip_comments=True, skip_whitespace=True\\)\n            decl_map = \\{\\}\n            important_flag = False\n            for decl in decls:\n                if decl\\.type != 'declaration':\n                    continue\n                value = tinycss2\\.serialize\\(decl\\.value\\)\\.strip\\(\\)\n                decl_map\\[decl\\.name\\.lower\\(\\)\\] = value\n                if decl\\.important:\n                    important_flag = True\n            start_line = getattr\\(rule, 'source_line', None\\)\n            end_line = start_line\n            for token in rule\\.content or \\[\\]:\n                if hasattr\\(token, 'source_line'\\):\n                    end_line = max\\(end_line, token\\.source_line\\)\n            if end_line is None:\n                end_line = start_line\n            ctx_tags = set\\(\\)\n            if not ctx_stack:\n                ctx_tags\\.add\\('base'\\)\n            for ctx in ctx_stack:\n                if ctx\\['type'\\] == 'media':\n                    txt = ctx\\['text'\\]\n                    match = media_ctx_re\\.search\\(txt\\)\n                    if match:\n                        ctx_tags\\.add\\(f\"media\\(\\{match\\.group\\(1\\)\\} \\{match\\.group\\(2\\)\\}\\)\"\\)\n                    else:\n                        ctx_tags\\.add\\(f\"media\\(\\{txt\\}\\)\"\\)\n                else:\n                    ctx_tags\\.add\\(ctx\\['text'\\]\\)\n            if not ctx_tags:\n                ctx_tags\\.add\\('base'\\)\n            for sel in selectors:\n                sel_clean = re\\.sub\\(r'\\\\\\\\s\\+', ' ', sel\\)\\.strip\\(\\)\n                sel_ctx = ctx_tags\\.copy\\(\\)\n                if sel_clean\\.startswith\\('body'\\) or ' body' in sel_clean:\n                    sel_ctx\\.add\\('page-scope'\\)\n                occurrence = \\{\n                    'selector': sel_clean,\n                    'start': start_line,\n                    'end': end_line,\n                    'contexts': sorted\\(sel_ctx\\),\n                    'important': important_flag,\n                    'declarations': decl_map,\n                \\}\n                storage\\[sel_clean\\]\\.append\\(occurrence\\)\n                conflict_inputs\\[sel_clean\\]\\.append\\(occurrence\\)\n\ngather\\(rules, \\[\\]\\)\n\nregistry = \\[\\]\nfor sel, occs in storage\\.items\\(\\):\n    contexts = sorted\\(\\{ctx for occ in occs for ctx in occ\\['contexts'\\]\\}\\)\n    important_used = any\\(occ\\['important'\\] for occ in occs\\)\n    occurrences = \\[f\"L\\{occ\\['start'\\]\\}-L\\{occ\\['end'\\]\\}\" if occ\\['start'\\] is not None else \"L\\?-L\\?\" for occ in occs\\]\n    registry\\.append\\(\\{\n        'selector': sel,\n        'count': len\\(occs\\),\n        'occurrences': occurrences,\n        'contexts': contexts,\n        'important_used': important_used\n    \\}\\)\n\nregistry\\.sort\\(key=lambda x: x\\['selector'\\]\\)\n\nconflicts = \\[\\]\nfor sel, occs in conflict_inputs\\.items\\(\\):\n    if len\\(occs\\) < 2:\n        continue\n    prop_map = defaultdict\\(list\\)\n    for occ in occs:\n        for prop, val in occ\\['declarations'\\]\\.items\\(\\):\n            prop_map\\[prop\\]\\.append\\(\\(val, occ\\)\\)\n    conflict_props = \\[\\]\n    for prop, entries in prop_map\\.items\\(\\):\n        values = \\{val for val, _ in entries\\}\n        if len\\(values\\) > 1:\n            entries_sorted = sorted\\(entries, key=lambda item: \\(0 if item\\[1\\]\\['important'\\] else 1, item\\[1\\]\\['start'\\]\\), reverse=True\\)\n            winner = entries_sorted\\[0\\]\\[1\\]\n            risk = classify\\(prop\\)\n            conflict_props\\.append\\(\\{\n                'property': prop,\n                'values': sorted\\(values\\),\n                'winner_range': f\"L\\{winner\\['start'\\]\\}-L\\{winner\\['end'\\]\\}\",\n                'risk': risk\n            \\}\\)\n    if conflict_props:\n        conflict_props\\.sort\\(key=lambda x: x\\['property'\\]\\)\n        conflicts\\.append\\(\\{\n            'selector': sel,\n            'conflicts': conflict_props,\n            'occurrence_count': len\\(occs\\)\n        \\}\\)\n\nconflicts\\.sort\\(key=lambda x: \\(-len\\(x\\['conflicts'\\]\\), -x\\['occurrence_count'\\]\\)\\)\n\nsummary = \\{\n    'unique_selectors': len\\(storage\\),\n    'multi_selectors': sum\\(1 for sel, occs in storage\\.items\\(\\) if len\\(occs\\) >= 2\\),\n    'most_repeated': Counter\\(\\{sel: len\\(occs\\) for sel, occs in storage\\.items\\(\\)\\}\\)\\.most_common\\(10\\)\n\\}\n\npath = pathlib\\.Path\\('/tmp/kg_css_audit\\.json'\\)\npath\\.write_text\\(json\\.dumps\\(\\{'registry': registry, 'conflicts': conflicts, 'summary': summary\\}, ensure_ascii=False\\)\\)\nprint\\('written', path\\)\n\"\"\"\nopen\\('/tmp/kg_audit\\.py','w'\\)\\.write\\(script\\)\nPY$/": {
      "approve": true,
      "matchCommandLine": true
    },
    "/^cd /Users/evgenijtazelnikov/Documents/kg && python - <<'PY'\nimport tinycss2,pathlib,json,re\nfrom collections import defaultdict,Counter\ntext=pathlib\\.Path\\('styles\\.css'\\)\\.read_text\\(\\)\nstorage=defaultdict\\(list\\)\nmedia_re=re\\.compile\\(r'\\(min\\|max\\)-width\\\\s\\*:\\\\s\\*\\(\\[0-9\\.\\]\\+\\\\s\\*\\(\\?:px\\|rem\\|vw\\|vh\\|vmin\\|vmax\\|em\\|%\\)\\?\\)',re\\.I\\)\n\ndef split_selectors\\(txt\\):\n    parts=\\[\\];buf=\\[\\];depth=0\n    for ch in txt:\n        if ch in '\\(\\[\\{': depth\\+=1\n        elif ch in '\\)\\]\\}' and depth>0: depth-=1\n        if ch==',' and depth==0:\n            sel=''\\.join\\(buf\\)\\.strip\\(\\)\n            if sel: parts\\.append\\(sel\\)\n            buf=\\[\\]\n        else:\n            buf\\.append\\(ch\\)\n    tail=''\\.join\\(buf\\)\\.strip\\(\\)\n    if tail: parts\\.append\\(tail\\)\n    return parts\n\nrules=tinycss2\\.parse_stylesheet\\(text,skip_comments=True,skip_whitespace=True\\)\nLAYOUT=\\{'display','position','top','right','bottom','left','width','min-width','max-width','height','min-height','max-height','margin','margin-top','margin-right','margin-bottom','margin-left','padding','padding-top','padding-right','padding-bottom','padding-left','grid','grid-template','grid-template-columns','grid-template-rows','grid-column','grid-row','grid-auto-flow','grid-auto-columns','grid-auto-rows','gap','column-gap','row-gap','align-items','justify-content','align-content','align-self','justify-items','flex','flex-grow','flex-shrink','flex-basis','flex-direction','flex-wrap','order','float','clear','overflow','overflow-x','overflow-y','object-fit','object-position','transform','transform-origin','clip-path','z-index','isolation','inset','inset-block','inset-inline','place-items','place-content'\\}\nTYPO=\\{'font','font-size','font-weight','font-family','font-style','line-height','letter-spacing','text-transform','text-decoration','text-align','text-indent','text-shadow','text-rendering','text-wrap','text-overflow','white-space','word-break','word-spacing','hyphens'\\}\nANIM=\\{'transition','transition-property','transition-duration','transition-delay','transition-timing-function','animation','animation-name','animation-duration','animation-delay','animation-direction','animation-iteration-count','animation-fill-mode','animation-play-state','@keyframes'\\}\n\ndef classify\\(prop\\):\n    prop=prop\\.lower\\(\\)\n    if prop in LAYOUT or prop\\.startswith\\(\\('grid','flex','justify','align'\\)\\) or prop in \\{'max-lines','columns'\\}: return 'layout'\n    if prop in TYPO: return 'typography'\n    if prop in ANIM or prop\\.startswith\\('animation'\\): return 'animation'\n    return 'skin'\n\nconflict_inputs=defaultdict\\(list\\)\n\ndef serialize\\(tokens\\):\n    return tinycss2\\.serialize\\(tokens\\)\\.strip\\(\\)\n\ndef parse_rule_list\\(tokens\\):\n    return tinycss2\\.parse_rule_list\\(tokens,skip_comments=True,skip_whitespace=True\\)\n\ndef gather\\(rules,ctx\\):\n    for rule in rules:\n        if rule\\.type=='at-rule':\n            if rule\\.content is None: continue\n            inner=parse_rule_list\\(rule\\.content\\)\n            new_ctx=ctx\\.copy\\(\\)\n            if rule\\.at_keyword\\.lower\\(\\)=='media':\n                new_ctx\\.append\\(\\{'type':'media','text':serialize\\(rule\\.prelude\\)\\}\\)\n            else:\n                new_ctx\\.append\\(\\{'type':'at','text':'@'\\+rule\\.at_keyword\\}\\)\n            gather\\(inner,new_ctx\\)\n        elif rule\\.type=='qualified-rule':\n            selectors=split_selectors\\(serialize\\(rule\\.prelude\\)\\)\n            if not selectors: continue\n            decls=tinycss2\\.parse_declaration_list\\(rule\\.content,skip_comments=True,skip_whitespace=True\\)\n            decl_map=\\{\\}\n            important=False\n            for decl in decls:\n                if decl\\.type!='declaration': continue\n                decl_map\\[decl\\.name\\.lower\\(\\)\\]=tinycss2\\.serialize\\(decl\\.value\\)\\.strip\\(\\)\n                if decl\\.important: important=True\n            start=getattr\\(rule,'source_line',None\\)\n            end=start\n            for token in rule\\.content or \\[\\]:\n                if hasattr\\(token,'source_line'\\):\n                    end=max\\(end,token\\.source_line\\)\n            ctx_tags=set\\(\\)\n            if not ctx: ctx_tags\\.add\\('base'\\)\n            for c in ctx:\n                if c\\['type'\\]=='media':\n                    match=media_re\\.search\\(c\\['text'\\]\\)\n                    if match:\n                        ctx_tags\\.add\\(f\"media\\(\\{match\\.group\\(1\\)\\} \\{match\\.group\\(2\\)\\}\\)\"\\)\n                    else:\n                        ctx_tags\\.add\\(f\"media\\(\\{c\\['text'\\]\\}\\)\"\\)\n                else:\n                    ctx_tags\\.add\\(c\\['text'\\]\\)\n            if not ctx_tags: ctx_tags\\.add\\('base'\\)\n            for sel in selectors:\n                sel_clean=re\\.sub\\(r'\\\\s\\+',' ',sel\\)\\.strip\\(\\)\n                sel_ctx=set\\(ctx_tags\\)\n                if sel_clean\\.startswith\\('body'\\) or ' body' in sel_clean:\n                    sel_ctx\\.add\\('page-scope'\\)\n                occ=\\{'selector':sel_clean,'start':start,'end':end,'contexts':sorted\\(sel_ctx\\),'important':important,'declarations':decl_map\\}\n                storage\\[sel_clean\\]\\.append\\(occ\\)\n                conflict_inputs\\[sel_clean\\]\\.append\\(occ\\)\n\ngather\\(rules,\\[\\]\\)\nregistry=\\[\\]\nfor sel,occs in storage\\.items\\(\\):\n    contexts=sorted\\(\\{ctx for occ in occs for ctx in occ\\['contexts'\\]\\}\\)\n    important_used=any\\(occ\\['important'\\] for occ in occs\\)\n    occ_ranges=\\[f\"L\\{occ\\['start'\\]\\}-L\\{occ\\['end'\\]\\}\" if occ\\['start'\\] is not None else 'L\\?-L\\?' for occ in occs\\]\n    registry\\.append\\(\\{'selector':sel,'count':len\\(occs\\),'occurrences':occ_ranges,'contexts':contexts,'important_used':important_used\\}\\)\nregistry\\.sort\\(key=lambda x:x\\['selector'\\]\\)\nconflicts=\\[\\]\nfor sel,occs in conflict_inputs\\.items\\(\\):\n    if len\\(occs\\)<2: continue\n    prop_map=defaultdict\\(list\\)\n    for occ in occs:\n        for prop,val in occ\\['declarations'\\]\\.items\\(\\):\n            prop_map\\[prop\\]\\.append\\(\\(val,occ\\)\\)\n    conflict_props=\\[\\]\n    for prop,entries in prop_map\\.items\\(\\):\n        vals=\\{val for val,_ in entries\\}\n        if len\\(vals\\)>1:\n            entries_sorted=sorted\\(entries,key=lambda item:\\(0 if item\\[1\\]\\['important'\\] else 1,item\\[1\\]\\['start'\\]\\),reverse=True\\)\n            winner=entries_sorted\\[0\\]\\[1\\]\n            conflict_props\\.append\\(\\{'property':prop,'values':sorted\\(vals\\),'winner_range':f\"L\\{winner\\['start'\\]\\}-L\\{winner\\['end'\\]\\}\",'risk':classify\\(prop\\)\\}\\)\n    if conflict_props:\n        conflict_props\\.sort\\(key=lambda x:x\\['property'\\]\\)\n        conflicts\\.append\\(\\{'selector':sel,'conflicts':conflict_props,'occurrence_count':len\\(occs\\)\\}\\)\nconflicts\\.sort\\(key=lambda x:\\(-len\\(x\\['conflicts'\\]\\),-x\\['occurrence_count'\\]\\)\\)\nsummary=\\{'unique_selectors':len\\(storage\\),'multi_selectors':sum\\(1 for occs in storage\\.values\\(\\) if len\\(occs\\)>=2\\),'most_repeated':Counter\\(\\{sel:len\\(occs\\) for sel,occs in storage\\.items\\(\\)\\}\\)\\.most_common\\(10\\)\\}\npath=pathlib\\.Path\\('/tmp/kg_css_audit\\.json'\\)\npath\\.write_text\\(json\\.dumps\\(\\{'registry':registry,'conflicts':conflicts,'summary':summary\\},ensure_ascii=False\\)\\)\nprint\\('written',path\\)\nprint\\('summary',summary\\)\nprint\\('top_conflicts',len\\(conflicts\\)\\)\nPY$/": {
      "approve": true,
      "matchCommandLine": true
    },
    "m.group(1)": true,
    "m.group(2)": true,
    "m": true,
    "else:": true,
    "not": true,
    "ctx_tags.add('base')": true,
    "'base'": true,
    "/^cd /Users/evgenijtazelnikov/Documents/kg && python3 - <<'PY'\nimport cssutils\nfrom collections import defaultdict\ncssutils\\.log\\.setLevel\\('FATAL'\\)\nsheet = cssutils\\.parseFile\\('styles\\.css'\\)\nrule_records = \\[\\]\n\ndef walk\\(rule, context\\):\n    rtype = rule\\.type\n    if rtype == rule\\.MEDIA_RULE:\n        new_context = context \\+ \\[f'@media \\{rule\\.media\\.mediaText\\.strip\\(\\)\\}'\\]\n        for child in rule\\.cssRules:\n            walk\\(child, new_context\\)\n    elif rtype == rule\\.SUPPORTS_RULE:\n        new_context = context \\+ \\[f'@supports \\{rule\\.conditionText\\.strip\\(\\)\\}'\\]\n        for child in rule\\.cssRules:\n            walk\\(child, new_context\\)\n    elif rtype == rule\\.STYLE_RULE:\n        selectors = \\[s\\.strip\\(\\) for s in rule\\.selectorText\\.split\\(','\\) if s\\.strip\\(\\)\\]\n        props = \\{\\}\n        for decl in rule\\.style:\n            if decl\\.type != decl\\.PROPERTY:\n                continue\n            props\\[decl\\.name\\] = decl\\.value\\.strip\\(\\)\n        for sel in selectors:\n            rule_records\\.append\\(\\{\n                'selector': sel,\n                'context': tuple\\(context\\),\n                'line': rule\\.line,\n                'properties': props\\.copy\\(\\),\n            \\}\\)\n    else:\n        # generic recurse if nested rules exist\n        for child in getattr\\(rule, 'cssRules', \\[\\]\\) or \\[\\]:\n            walk\\(child, context\\)\n\nfor top in sheet:\n    walk\\(top, \\[\\]\\)\n\nby_selector = defaultdict\\(list\\)\nfor rec in rule_records:\n    key = \\(rec\\['context'\\], rec\\['selector'\\]\\)\n    by_selector\\[key\\]\\.append\\(rec\\)\n\nduplicates = \\[\\]\nconflicts = \\[\\]\nfor key, entries in by_selector\\.items\\(\\):\n    if len\\(entries\\) > 1:\n        lines = \\[e\\['line'\\] for e in entries\\]\n        duplicates\\.append\\(\\(key, lines\\)\\)\n        prop_values = defaultdict\\(set\\)\n        for e in entries:\n            for name, value in e\\['properties'\\]\\.items\\(\\):\n                prop_values\\[name\\]\\.add\\(value\\)\n        conflicting = \\{name: sorted\\(vals\\) for name, vals in prop_values\\.items\\(\\) if len\\(vals\\) > 1\\}\n        if conflicting:\n            conflicts\\.append\\(\\(key, lines, conflicting\\)\\)\n\nprint\\('Total unique selector/context pairs:', len\\(by_selector\\)\\)\nprint\\('Total duplicates:', len\\(duplicates\\)\\)\nprint\\('Total conflicts:', len\\(conflicts\\)\\)\nprint\\('\\\\nSample duplicates \\(first 20\\):'\\)\nfor \\(context, selector\\), lines in duplicates\\[:20\\]:\n    ctx = ' > '\\.join\\(context\\) if context else 'global'\n    print\\(f'\\[\\{ctx\\}\\] \\{selector\\} -> lines \\{lines\\}'\\)\n\nprint\\('\\\\nSample conflicts \\(first 20\\):'\\)\nfor \\(context, selector\\), lines, props in conflicts\\[:20\\]:\n    ctx = ' > '\\.join\\(context\\) if context else 'global'\n    prop_desc = ', '\\.join\\(f\"\\{p\\}:\\{'/'\\.join\\(vals\\)\\}\" for p, vals in props\\.items\\(\\)\\)\n    print\\(f'\\[\\{ctx\\}\\] \\{selector\\} -> lines \\{lines\\} conflicts: \\{prop_desc\\}'\\)\nPY$/": {
      "approve": true,
      "matchCommandLine": true
    },
    "/^cd /Users/evgenijtazelnikov/Documents/kg && python3 - <<'PY' > _tmp/css_audit_output\\.txt\nimport cssutils\nfrom collections import defaultdict\ncssutils\\.log\\.setLevel\\('FATAL'\\)\nsheet = cssutils\\.parseFile\\('styles\\.css'\\)\nrule_records = \\[\\]\n\ndef walk\\(rule, context\\):\n    rtype = rule\\.type\n    if rtype == rule\\.MEDIA_RULE:\n        new_context = context \\+ \\[f'@media \\{rule\\.media\\.mediaText\\.strip\\(\\)\\}'\\]\n        for child in rule\\.cssRules:\n            walk\\(child, new_context\\)\n    elif rtype == rule\\.SUPPORTS_RULE:\n        new_context = context \\+ \\[f'@supports \\{rule\\.conditionText\\.strip\\(\\)\\}'\\]\n        for child in rule\\.cssRules:\n            walk\\(child, new_context\\)\n    elif rtype == rule\\.STYLE_RULE:\n        selectors = \\[s\\.strip\\(\\) for s in rule\\.selectorText\\.split\\(','\\) if s\\.strip\\(\\)\\]\n        props = \\{\\}\n        for decl in rule\\.style:\n            if decl\\.type != decl\\.PROPERTY:\n                continue\n            props\\[decl\\.name\\] = decl\\.value\\.strip\\(\\)\n        for sel in selectors:\n            rule_records\\.append\\(\\{\n                'selector': sel,\n                'context': tuple\\(context\\),\n                'line': rule\\.line,\n                'properties': props\\.copy\\(\\),\n            \\}\\)\n    else:\n        for child in getattr\\(rule, 'cssRules', \\[\\]\\) or \\[\\]:\n            walk\\(child, context\\)\n\nfor top in sheet:\n    walk\\(top, \\[\\]\\)\n\nby_selector = defaultdict\\(list\\)\nfor rec in rule_records:\n    key = \\(rec\\['context'\\], rec\\['selector'\\]\\)\n    by_selector\\[key\\]\\.append\\(rec\\)\n\nduplicates = \\[\\]\nconflicts = \\[\\]\nfor key, entries in by_selector\\.items\\(\\):\n    if len\\(entries\\) > 1:\n        lines = \\[e\\['line'\\] for e in entries\\]\n        duplicates\\.append\\(\\(key, lines\\)\\)\n        prop_values = defaultdict\\(set\\)\n        for e in entries:\n            for name, value in e\\['properties'\\]\\.items\\(\\):\n                prop_values\\[name\\]\\.add\\(value\\)\n        conflicting = \\{name: sorted\\(vals\\) for name, vals in prop_values\\.items\\(\\) if len\\(vals\\) > 1\\}\n        if conflicting:\n            conflicts\\.append\\(\\(key, lines, conflicting\\)\\)\n\nprint\\('Total unique selector/context pairs:', len\\(by_selector\\)\\)\nprint\\('Total duplicates:', len\\(duplicates\\)\\)\nprint\\('Total conflicts:', len\\(conflicts\\)\\)\nprint\\('\\\\nSample duplicates \\(first 20\\):'\\)\nfor \\(context, selector\\), lines in duplicates\\[:20\\]:\n    ctx = ' > '\\.join\\(context\\) if context else 'global'\n    print\\(f'\\[\\{ctx\\}\\] \\{selector\\} -> lines \\{lines\\}'\\)\n\nprint\\('\\\\nSample conflicts \\(first 20\\):'\\)\nfor \\(context, selector\\), lines, props in conflicts\\[:20\\]:\n    ctx = ' > '\\.join\\(context\\) if context else 'global'\n    prop_desc = ', '\\.join\\(f\"\\{p\\}:\\{'/'\\.join\\(vals\\)\\}\" for p, vals in props\\.items\\(\\)\\)\n    print\\(f'\\[\\{ctx\\}\\] \\{selector\\} -> lines \\{lines\\} conflicts: \\{prop_desc\\}'\\)\nPY$/": {
      "approve": true,
      "matchCommandLine": true
    },
    "/^python3 _tmp/css_audit\\.py > _tmp/css_audit_output\\.txt$/": {
      "approve": true,
      "matchCommandLine": true
    }
  }
}